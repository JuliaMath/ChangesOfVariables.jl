var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Interface","page":"API","title":"Interface","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"with_logabsdet_jacobian\nNoLogAbsDetJacobian\nsetladj","category":"page"},{"location":"api/#ChangesOfVariables.with_logabsdet_jacobian","page":"API","title":"ChangesOfVariables.with_logabsdet_jacobian","text":"with_logabsdet_jacobian(f, x)\n\nComputes both the transformed value of x under the transformation f and the logarithm of the volume element.\n\nFor (y, ladj) = with_logabsdet_jacobian(f, x), the following must hold true:\n\ny == f(x)\nladj is the log(abs(det(jacobian(f, x))))\n\nwith_logabsdet_jacobian comes with support for broadcasted/mapped functions (via Base.Broadcast.BroadcastFunction or Base.Fix1) and ComposedFunction.\n\nIf no volume element is defined/applicable, with_logabsdet_jacobian(f::F, x::T) returns NoLogAbsDetJacobian{F,T}().\n\nExamples\n\nusing ChangesOfVariables\n\nfoo(x) = inv(exp(-x) + 1)\n\nfunction ChangesOfVariables.with_logabsdet_jacobian(::typeof(foo), x)\n    y = foo(x)\n    ladj = -x + 2 * log(y)\n    (y, ladj)\nend\n\nx = 4.2\ny, ladj_y = with_logabsdet_jacobian(foo, x)\n\nusing LinearAlgebra, ForwardDiff\ny == foo(x) && ladj_y ≈ log(abs(ForwardDiff.derivative(foo, x)))\n\n# output\n\ntrue\n\nX = rand(10)\nbroadcasted_foo = if VERSION >= v\"1.6\"\n    Base.Broadcast.BroadcastFunction(foo)\nelse\n    Base.Fix1(broadcast, foo)\nend\nY, ladj_Y = with_logabsdet_jacobian(broadcasted_foo, X)\nY == broadcasted_foo(X) && ladj_Y ≈ logabsdet(ForwardDiff.jacobian(broadcasted_foo, X))[1]\n\n# output\n\ntrue\n\nVERSION < v\"1.6\" || begin # Support for ∘ requires Julia >= v1.6\n    z, ladj_z = with_logabsdet_jacobian(log ∘ foo, x)\n    z == log(foo(x)) && ladj_z == ladj_y + with_logabsdet_jacobian(log, y)[2]\nend\n\n# output\n\ntrue\n\nImplementations of withlogabsdetjacobian can be tested (as a Test.@testset) using ChangesOfVariables.test_with_logabsdet_jacobian.\n\n\n\n\n\n","category":"function"},{"location":"api/#ChangesOfVariables.NoLogAbsDetJacobian","page":"API","title":"ChangesOfVariables.NoLogAbsDetJacobian","text":"struct NoLogAbsDetJacobian{F,T}\n\nAn instance NoLogAbsDetJacobian{F,T}() signifies that with_logabsdet_jacobian(::F, ::T) is not defined.\n\n\n\n\n\n","category":"type"},{"location":"api/#ChangesOfVariables.setladj","page":"API","title":"ChangesOfVariables.setladj","text":"setladj(f, ladjf)::Function\n\nReturn a function that behaves like f in general and which has with_logabsdet_jacobian(f, x) = f(x), ladjf(x).\n\nUseful in cases where with_logabsdet_jacobian is not defined for f, or if f needs to be assigned a LADJ-calculation that is only valid within a given context, e.g. only for a limited argument type/range that is guaranteed by the use case but not in general, or that is optimized to a custom use case.\n\nFor example, CUDA.CuArray has no with_logabsdet_jacobian defined, but may be used to switch computing device for a part of a heterogenous computing function chain. Likewise, one may want to switch numerical precision for a part of a calculation.\n\nThe function (wrapper) returned by setladj supports InverseFunctions.inverse if f does so.\n\nExample:\n\nVERSION < v\"1.6\" || begin # Support for ∘ requires Julia >= v1.6\n    # Increases precition before calculation exp:\n    foo = exp ∘ setladj(setinverse(Float64, Float32), _ -> 0)\n\n    # A log-value from some low-precision (e.g. GPU) computation:\n    log_x = Float32(100)\n\n    # f(log_x) would return Inf32 without going to Float64:\n    y, ladj = with_logabsdet_jacobian(foo, log_x) \n\n    r_log_x, ladj_inv = with_logabsdet_jacobian(inverse(foo), y)\n\n    ladj ≈ 100 ≈ -ladj_inv && r_log_x ≈ log_x\nend\n# output\n\ntrue\n\n\n\n\n\n","category":"function"},{"location":"api/#Test-utility","page":"API","title":"Test utility","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ChangesOfVariables.test_with_logabsdet_jacobian","category":"page"},{"location":"api/#ChangesOfVariables.test_with_logabsdet_jacobian","page":"API","title":"ChangesOfVariables.test_with_logabsdet_jacobian","text":"ChangesOfVariables.test_with_logabsdet_jacobian(f, x, getjacobian; compare = isapprox, kwargs...)\n\nTest if with_logabsdet_jacobian(f, x) is implemented correctly.\n\nChecks if the result of with_logabsdet_jacobian(f, x) is approximately equal to (f(x), logabsdet(getjacobian(f, x)))\n\nSo the test uses getjacobian(f, x) to calculate a reference Jacobian for f at x. Passing ForwardDiff.jabobian, Zygote.jacobian or similar as the getjacobian function will do fine in most cases. If input and output of f are real scalar values, use ForwardDiff.derivative.\n\nNote that the result of getjacobian(f, x) must be a real-valued matrix or a real scalar, so you may need to use a custom getjacobian function that transforms the shape of x and f(x) internally, in conjunction with automatic differentiation.\n\nkwargs... are forwarded to compare.\n\n!!! Note     On Julia >= 1.9, you have to load the Test standard library to be able to use     this function.\n\n\n\n\n\n","category":"function"},{"location":"api/#Additional-functionality","page":"API","title":"Additional functionality","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"ChangesOfVariables.FunctionWithLADJ","category":"page"},{"location":"api/#ChangesOfVariables.FunctionWithLADJ","page":"API","title":"ChangesOfVariables.FunctionWithLADJ","text":"struct FunctionWithLADJ{F,LADJF} <: Function\n\nA function with an separate function to compute it's logabddet(J).\n\nDo not construct directly, use setladj(f, ladjf) instead.\n\n\n\n\n\n","category":"type"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"using Markdown\nMarkdown.parse_file(joinpath(@__DIR__, \"..\", \"..\", \"LICENSE.md\"))","category":"page"},{"location":"#ChangesOfVariables.jl","page":"Home","title":"ChangesOfVariables.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ChangesOfVariables","category":"page"},{"location":"#ChangesOfVariables","page":"Home","title":"ChangesOfVariables","text":"ChangesOfVariables\n\nLightweight package that defines functionality to calculate volume element changes for functions that perform a change of variables (like coordinate transformations).\n\n\n\n\n\n","category":"module"},{"location":"","page":"Home","title":"Home","text":"This package defines the function with_logabsdet_jacobian. (y, ladj) = with_logabsdet_jacobian(f, x) computes both the transformed value of x under the transformation f and the logarithm of the volume element.","category":"page"},{"location":"","page":"Home","title":"Home","text":"with_logabsdet_jacobian supports mapped/broadcasted functions (via Base.Broadcast.BroadcastFunction or Base.Fix1) and function composition.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Implementations of with_logabsdet_jacobian(f) for identity, inv, adjoint and transpose as well as for exp, log, exp2, log2, exp10, log10, expm1 and log1p are included.","category":"page"}]
}
